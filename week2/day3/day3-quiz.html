<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Day 3: ServiceAccount & RBAC 퀴즈</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .quiz-container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            max-width: 800px;
            width: 100%;
            position: relative;
            overflow: hidden;
        }

        .quiz-header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 3px solid #f0f0f0;
            position: relative;
        }

        .quiz-header::before {
            content: '';
            position: absolute;
            bottom: -3px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 3px;
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
        }

        .quiz-title {
            font-size: 2.2em;
            color: #2d3748;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .quiz-subtitle {
            color: #718096;
            font-size: 1.1em;
            margin-bottom: 15px;
        }

        .progress-container {
            background: #e2e8f0;
            border-radius: 12px;
            height: 8px;
            margin: 15px 0;
            overflow: hidden;
        }

        .progress-bar {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            height: 100%;
            border-radius: 12px;
            transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            width: 0%;
        }

        .progress-text {
            text-align: center;
            margin: 10px 0;
            color: #4a5568;
            font-weight: 600;
        }

        .question-container {
            margin: 30px 0;
            padding: 25px;
            background: #f8fafc;
            border-radius: 15px;
            border-left: 5px solid #4f46e5;
            display: none;
        }

        .question-container.active {
            display: block;
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .question-number {
            color: #4f46e5;
            font-weight: 700;
            font-size: 1.1em;
            margin-bottom: 15px;
        }

        .question-text {
            font-size: 1.3em;
            color: #2d3748;
            margin-bottom: 25px;
            line-height: 1.5;
            font-weight: 600;
        }

        .options {
            display: grid;
            gap: 15px;
            margin-bottom: 25px;
        }

        .option {
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            padding: 18px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.05em;
            position: relative;
            overflow: hidden;
        }

        .option::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transition: left 0.5s;
        }

        .option:hover {
            border-color: #4f46e5;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(79, 70, 229, 0.15);
        }

        .option:hover::before {
            left: 100%;
        }

        .option.selected {
            border-color: #4f46e5;
            background: linear-gradient(135deg, #ede9fe 0%, #f3f4f6 100%);
            transform: translateY(-2px);
        }

        .option.correct {
            border-color: #10b981;
            background: linear-gradient(135deg, #d1fae5 0%, #f3f4f6 100%);
            color: #065f46;
        }

        .option.incorrect {
            border-color: #ef4444;
            background: linear-gradient(135deg, #fee2e2 0%, #f3f4f6 100%);
            color: #991b1b;
        }

        .option-label {
            font-weight: 700;
            color: #4f46e5;
            margin-right: 12px;
            font-size: 1.1em;
        }

        .answer-input {
            width: 100%;
            padding: 15px 20px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 1.1em;
            background: white;
            transition: all 0.3s ease;
            font-family: 'Monaco', 'Consolas', monospace;
        }

        .answer-input:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .answer-input.correct {
            border-color: #10b981;
            background: linear-gradient(135deg, #d1fae5 0%, #ffffff 100%);
        }

        .answer-input.incorrect {
            border-color: #ef4444;
            background: linear-gradient(135deg, #fee2e2 0%, #ffffff 100%);
        }

        .feedback {
            margin: 20px 0;
            padding: 18px 24px;
            border-radius: 12px;
            font-weight: 600;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.4s ease;
        }

        .feedback.show {
            opacity: 1;
            transform: translateY(0);
        }

        .feedback.correct {
            background: linear-gradient(135deg, #d1fae5 0%, #ecfdf5 100%);
            color: #065f46;
            border-left: 4px solid #10b981;
        }

        .feedback.incorrect {
            background: linear-gradient(135deg, #fee2e2 0%, #fef2f2 100%);
            color: #991b1b;
            border-left: 4px solid #ef4444;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 30px;
            gap: 20px;
        }

        .btn {
            padding: 14px 28px;
            border: none;
            border-radius: 12px;
            font-size: 1.05em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn-primary {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(79, 70, 229, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(79, 70, 229, 0.4);
        }

        .btn-primary:disabled {
            background: #a0aec0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6b7280 0%, #9ca3af 100%);
            color: white;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
        }

        .btn-secondary:disabled {
            background: #e5e7eb;
            color: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }

        .hint-btn {
            background: linear-gradient(135deg, #f59e0b 0%, #f97316 100%);
            color: white;
            font-size: 0.9em;
            padding: 10px 20px;
        }

        .hint-btn:hover {
            transform: translateY(-1px);
        }

        .hint {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            color: #92400e;
            padding: 15px 20px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #f59e0b;
            display: none;
        }

        .hint.show {
            display: block;
            animation: slideIn 0.4s ease-out;
        }

        .results {
            text-align: center;
            padding: 40px 20px;
            display: none;
        }

        .results.show {
            display: block;
            animation: slideIn 0.6s ease-out;
        }

        .score {
            font-size: 4em;
            font-weight: 800;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .score-message {
            font-size: 1.5em;
            color: #2d3748;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .score-detail {
            color: #718096;
            font-size: 1.2em;
            margin-bottom: 30px;
        }

        .medal {
            font-size: 5em;
            margin: 20px 0;
            animation: bounce 2s infinite;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-20px);
            }
            60% {
                transform: translateY(-10px);
            }
        }

        .all-answers-btn {
            background: linear-gradient(135deg, #059669 0%, #10b981 100%);
            color: white;
            margin-top: 20px;
        }

        .all-answers-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.3);
        }

        .all-answers {
            display: none;
            margin-top: 30px;
            padding: 25px;
            background: #f8fafc;
            border-radius: 15px;
            text-align: left;
        }

        .all-answers.show {
            display: block;
            animation: slideIn 0.5s ease-out;
        }

        .answer-item {
            padding: 15px 0;
            border-bottom: 1px solid #e2e8f0;
        }

        .answer-item:last-child {
            border-bottom: none;
        }

        .answer-question {
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 8px;
        }

        .answer-correct {
            color: #059669;
            font-weight: 600;
            font-family: 'Monaco', 'Consolas', monospace;
        }

        @media (max-width: 768px) {
            .quiz-container {
                margin: 10px;
                padding: 20px;
            }

            .quiz-title {
                font-size: 1.8em;
            }

            .question-text {
                font-size: 1.1em;
            }

            .controls {
                flex-direction: column;
                gap: 15px;
            }

            .btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="quiz-container">
        <div class="quiz-header">
            <div class="quiz-title">⚙️ Day 3: ServiceAccount & RBAC 퀴즈</div>
            <div class="quiz-subtitle">총 12문제 | CKA/CKAD 준비</div>
            <div class="progress-container">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            <div class="progress-text" id="progressText">1 / 12</div>
        </div>

        <!-- Question 1 -->
        <div class="question-container active" data-question="0">
            <div class="question-number">문제 1</div>
            <div class="question-text">ServiceAccount를 생성하는 명령어는?</div>
            <div class="options">
                <div class="option" data-answer="A">
                    <span class="option-label">A.</span> kubectl create sa webapp-sa
                </div>
                <div class="option" data-answer="B">
                    <span class="option-label">B.</span> kubectl create serviceaccount webapp-sa
                </div>
                <div class="option" data-answer="C">
                    <span class="option-label">C.</span> kubectl apply serviceaccount webapp-sa
                </div>
                <div class="option" data-answer="D">
                    <span class="option-label">D.</span> kubectl new serviceaccount webapp-sa
                </div>
            </div>
            <div class="feedback"></div>
            <div class="hint">
                💡 <strong>힌트:</strong> kubectl create 명령어는 여러 리소스 타입을 지원하며, serviceaccount의 축약형도 사용할 수 있습니다.
            </div>
        </div>

        <!-- Question 2 -->
        <div class="question-container" data-question="1">
            <div class="question-number">문제 2</div>
            <div class="question-text">특정 ServiceAccount로 권한을 테스트하는 명령어를 완성하세요.</div>
            <div style="margin-bottom: 15px;">
                <code>kubectl auth can-i get pods --as=_______________________</code>
            </div>
            <input type="text" class="answer-input" placeholder="ServiceAccount 전체 경로를 입력하세요">
            <div class="feedback"></div>
            <div class="hint">
                💡 <strong>힌트:</strong> system:serviceaccount:네임스페이스:ServiceAccount이름 형식을 사용합니다.
            </div>
        </div>

        <!-- Question 3 -->
        <div class="question-container" data-question="2">
            <div class="question-number">문제 3</div>
            <div class="question-text">Role과 ClusterRole의 가장 중요한 차이점은?</div>
            <div class="options">
                <div class="option" data-answer="A">
                    <span class="option-label">A.</span> Role은 읽기 전용, ClusterRole은 쓰기 가능
                </div>
                <div class="option" data-answer="B">
                    <span class="option-label">B.</span> Role은 특정 네임스페이스, ClusterRole은 클러스터 전체
                </div>
                <div class="option" data-answer="C">
                    <span class="option-label">C.</span> Role은 사용자용, ClusterRole은 ServiceAccount용
                </div>
                <div class="option" data-answer="D">
                    <span class="option-label">D.</span> Role은 임시, ClusterRole은 영구
                </div>
            </div>
            <div class="feedback"></div>
            <div class="hint">
                💡 <strong>힌트:</strong> 네임스페이스 기반 vs 클러스터 전체 범위를 생각해보세요.
            </div>
        </div>

        <!-- Question 4 -->
        <div class="question-container" data-question="3">
            <div class="question-number">문제 4</div>
            <div class="question-text">Pod 읽기 권한을 가진 Role을 생성하는 명령어는?</div>
            <input type="text" class="answer-input" placeholder="완전한 kubectl 명령어를 입력하세요">
            <div class="feedback"></div>
            <div class="hint">
                💡 <strong>힌트:</strong> kubectl create role 명령어에서 --verb와 --resource 옵션을 사용합니다.
            </div>
        </div>

        <!-- Question 5 -->
        <div class="question-container" data-question="4">
            <div class="question-number">문제 5</div>
            <div class="question-text">RoleBinding에서 ServiceAccount를 연결할 때 사용하는 옵션은?</div>
            <div class="options">
                <div class="option" data-answer="A">
                    <span class="option-label">A.</span> --user=default:webapp-sa
                </div>
                <div class="option" data-answer="B">
                    <span class="option-label">B.</span> --serviceaccount=default:webapp-sa
                </div>
                <div class="option" data-answer="C">
                    <span class="option-label">C.</span> --account=default:webapp-sa
                </div>
                <div class="option" data-answer="D">
                    <span class="option-label">D.</span> --sa=default:webapp-sa
                </div>
            </div>
            <div class="feedback"></div>
            <div class="hint">
                💡 <strong>힌트:</strong> kubectl create rolebinding --help 명령어로 확인할 수 있습니다.
            </div>
        </div>

        <!-- Question 6 -->
        <div class="question-container" data-question="5">
            <div class="question-number">문제 6</div>
            <div class="question-text">다음 중 올바른 RBAC 모범 사례는?</div>
            <div class="options">
                <div class="option" data-answer="A">
                    <span class="option-label">A.</span> 모든 ServiceAccount에 cluster-admin 권한 부여
                </div>
                <div class="option" data-answer="B">
                    <span class="option-label">B.</span> 최소 권한 원칙(Principle of Least Privilege) 적용
                </div>
                <div class="option" data-answer="C">
                    <span class="option-label">C.</span> default ServiceAccount만 사용
                </div>
                <div class="option" data-answer="D">
                    <span class="option-label">D.</span> 모든 권한을 ClusterRole로만 관리
                </div>
            </div>
            <div class="feedback"></div>
            <div class="hint">
                💡 <strong>힌트:</strong> 보안을 위해 필요한 최소한의 권한만 부여하는 것이 중요합니다.
            </div>
        </div>

        <!-- Question 7 -->
        <div class="question-container" data-question="6">
            <div class="question-number">문제 7</div>
            <div class="question-text">ServiceAccount 토큰 자동 마운트를 비활성화하는 설정은?</div>
            <input type="text" class="answer-input" placeholder="YAML 키: 값 형식으로 입력하세요">
            <div class="feedback"></div>
            <div class="hint">
                💡 <strong>힌트:</strong> ServiceAccount YAML에서 토큰 마운트를 제어하는 불린 설정입니다.
            </div>
        </div>

        <!-- Question 8 -->
        <div class="question-container" data-question="7">
            <div class="question-number">문제 8</div>
            <div class="question-text">현재 사용자의 모든 권한을 확인하는 명령어는?</div>
            <div class="options">
                <div class="option" data-answer="A">
                    <span class="option-label">A.</span> kubectl auth can-i --all
                </div>
                <div class="option" data-answer="B">
                    <span class="option-label">B.</span> kubectl auth can-i --list
                </div>
                <div class="option" data-answer="C">
                    <span class="option-label">C.</span> kubectl auth permissions
                </div>
                <div class="option" data-answer="D">
                    <span class="option-label">D.</span> kubectl get permissions
                </div>
            </div>
            <div class="feedback"></div>
            <div class="hint">
                💡 <strong>힌트:</strong> kubectl auth can-i 명령어의 옵션 중 하나입니다.
            </div>
        </div>

        <!-- Question 9 -->
        <div class="question-container" data-question="8">
            <div class="question-number">문제 9</div>
            <div class="question-text">Pod에서 특정 ServiceAccount를 사용하도록 설정하는 YAML 필드는?</div>
            <input type="text" class="answer-input" placeholder="YAML 필드명을 입력하세요">
            <div class="feedback"></div>
            <div class="hint">
                💡 <strong>힌트:</strong> Pod spec에서 ServiceAccount 이름을 지정하는 필드입니다.
            </div>
        </div>

        <!-- Question 10 -->
        <div class="question-container" data-question="9">
            <div class="question-number">문제 10</div>
            <div class="question-text">다음 중 ClusterRoleBinding을 생성하는 올바른 명령어는?</div>
            <div class="options">
                <div class="option" data-answer="A">
                    <span class="option-label">A.</span> kubectl create binding cluster-reader --clusterrole=reader --serviceaccount=default:sa
                </div>
                <div class="option" data-answer="B">
                    <span class="option-label">B.</span> kubectl create clusterrolebinding cluster-reader --clusterrole=reader --serviceaccount=default:sa
                </div>
                <div class="option" data-answer="C">
                    <span class="option-label">C.</span> kubectl create rolebinding cluster-reader --clusterrole=reader --serviceaccount=default:sa
                </div>
                <div class="option" data-answer="D">
                    <span class="option-label">D.</span> kubectl apply clusterrolebinding cluster-reader --clusterrole=reader --serviceaccount=default:sa
                </div>
            </div>
            <div class="feedback"></div>
            <div class="hint">
                💡 <strong>힌트:</strong> ClusterRoleBinding 생성을 위한 정확한 명령어 구조를 생각해보세요.
            </div>
        </div>

        <!-- Question 11 -->
        <div class="question-container" data-question="10">
            <div class="question-number">문제 11</div>
            <div class="question-text">RBAC 권한 부여에서 "Forbidden" 에러가 발생했을 때, 가장 먼저 확인해야 할 명령어는?</div>
            <input type="text" class="answer-input" placeholder="권한을 확인하는 kubectl 명령어를 입력하세요">
            <div class="feedback"></div>
            <div class="hint">
                💡 <strong>힌트:</strong> 특정 작업이 허용되는지 확인하는 kubectl auth 명령어입니다.
            </div>
        </div>

        <!-- Question 12 -->
        <div class="question-container" data-question="11">
            <div class="question-number">문제 12</div>
            <div class="question-text">다음 중 보안상 가장 위험한 RBAC 설정은?</div>
            <div class="options">
                <div class="option" data-answer="A">
                    <span class="option-label">A.</span> 특정 Pod에만 접근할 수 있는 Role
                </div>
                <div class="option" data-answer="B">
                    <span class="option-label">B.</span> 읽기 전용 ClusterRole
                </div>
                <div class="option" data-answer="C">
                    <span class="option-label">C.</span> 모든 리소스에 모든 권한을 가진 ClusterRole
                </div>
                <div class="option" data-answer="D">
                    <span class="option-label">D.</span> 네임스페이스별로 분리된 Role
                </div>
            </div>
            <div class="feedback"></div>
            <div class="hint">
                💡 <strong>힌트:</strong> 최소 권한 원칙에 가장 위배되는 설정을 찾아보세요.
            </div>
        </div>

        <div class="controls">
            <button class="btn btn-secondary" id="prevBtn" disabled>이전</button>
            <button class="btn hint-btn" id="hintBtn">💡 힌트</button>
            <button class="btn btn-primary" id="checkBtn">정답 확인</button>
            <button class="btn btn-secondary" id="nextBtn" disabled>다음</button>
        </div>

        <div class="results" id="results">
            <div class="medal" id="medal"></div>
            <div class="score" id="finalScore">0/12</div>
            <div class="score-message" id="scoreMessage">훌륭합니다!</div>
            <div class="score-detail" id="scoreDetail">ServiceAccount & RBAC 마스터!</div>
            <button class="btn all-answers-btn" id="showAllAnswers">모든 정답 보기</button>
            
            <div class="all-answers" id="allAnswers">
                <h3 style="margin-bottom: 20px; color: #2d3748;">📋 전체 정답</h3>
                <div class="answer-item">
                    <div class="answer-question">1. ServiceAccount를 생성하는 명령어는?</div>
                    <div class="answer-correct">정답: B. kubectl create serviceaccount webapp-sa (A도 정답)</div>
                </div>
                <div class="answer-item">
                    <div class="answer-question">2. 특정 ServiceAccount로 권한을 테스트하는 명령어 완성</div>
                    <div class="answer-correct">정답: system:serviceaccount:default:webapp-sa</div>
                </div>
                <div class="answer-item">
                    <div class="answer-question">3. Role과 ClusterRole의 가장 중요한 차이점은?</div>
                    <div class="answer-correct">정답: B. Role은 특정 네임스페이스, ClusterRole은 클러스터 전체</div>
                </div>
                <div class="answer-item">
                    <div class="answer-question">4. Pod 읽기 권한을 가진 Role 생성 명령어</div>
                    <div class="answer-correct">정답: kubectl create role pod-reader --verb=get,list,watch --resource=pods</div>
                </div>
                <div class="answer-item">
                    <div class="answer-question">5. RoleBinding에서 ServiceAccount를 연결할 때 사용하는 옵션</div>
                    <div class="answer-correct">정답: B. --serviceaccount=default:webapp-sa</div>
                </div>
                <div class="answer-item">
                    <div class="answer-question">6. 올바른 RBAC 모범 사례는?</div>
                    <div class="answer-correct">정답: B. 최소 권한 원칙(Principle of Least Privilege) 적용</div>
                </div>
                <div class="answer-item">
                    <div class="answer-question">7. ServiceAccount 토큰 자동 마운트 비활성화 설정</div>
                    <div class="answer-correct">정답: automountServiceAccountToken: false</div>
                </div>
                <div class="answer-item">
                    <div class="answer-question">8. 현재 사용자의 모든 권한을 확인하는 명령어</div>
                    <div class="answer-correct">정답: B. kubectl auth can-i --list</div>
                </div>
                <div class="answer-item">
                    <div class="answer-question">9. Pod에서 특정 ServiceAccount를 사용하도록 설정하는 YAML 필드</div>
                    <div class="answer-correct">정답: serviceAccountName</div>
                </div>
                <div class="answer-item">
                    <div class="answer-question">10. ClusterRoleBinding을 생성하는 올바른 명령어</div>
                    <div class="answer-correct">정답: B. kubectl create clusterrolebinding cluster-reader --clusterrole=reader --serviceaccount=default:sa</div>
                </div>
                <div class="answer-item">
                    <div class="answer-question">11. "Forbidden" 에러 시 가장 먼저 확인해야 할 명령어</div>
                    <div class="answer-correct">정답: kubectl auth can-i <verb> <resource></div>
                </div>
                <div class="answer-item">
                    <div class="answer-question">12. 보안상 가장 위험한 RBAC 설정</div>
                    <div class="answer-correct">정답: C. 모든 리소스에 모든 권한을 가진 ClusterRole</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const questions = [
            {
                type: 'multiple',
                correct: ['A', 'B'], // kubectl create sa 또는 kubectl create serviceaccount 둘 다 정답
                explanation: '정답: B. kubectl create serviceaccount webapp-sa<br>ServiceAccount는 축약형 "sa"로도 생성 가능합니다. (A도 정답)'
            },
            {
                type: 'text',
                correct: ['system:serviceaccount:default:webapp-sa'],
                explanation: '정답: system:serviceaccount:default:webapp-sa<br>ServiceAccount의 전체 경로는 system:serviceaccount:네임스페이스:ServiceAccount이름 형식입니다.'
            },
            {
                type: 'multiple',
                correct: ['B'],
                explanation: '정답: B. Role은 특정 네임스페이스, ClusterRole은 클러스터 전체<br>Role은 네임스페이스 범위, ClusterRole은 클러스터 전체 범위에서 권한을 정의합니다.'
            },
            {
                type: 'text',
                correct: ['kubectl create role pod-reader --verb=get,list,watch --resource=pods'],
                explanation: '정답: kubectl create role pod-reader --verb=get,list,watch --resource=pods<br>Role 생성 시 --verb로 허용할 동작, --resource로 대상 리소스를 지정합니다.'
            },
            {
                type: 'multiple',
                correct: ['B'],
                explanation: '정답: B. --serviceaccount=default:webapp-sa<br>RoleBinding에서는 --serviceaccount 옵션으로 ServiceAccount를 지정합니다.'
            },
            {
                type: 'multiple',
                correct: ['B'],
                explanation: '정답: B. 최소 권한 원칙(Principle of Least Privilege) 적용<br>보안을 위해 필요한 최소한의 권한만 부여하는 것이 RBAC의 핵심 원칙입니다.'
            },
            {
                type: 'text',
                correct: ['automountServiceAccountToken: false'],
                explanation: '정답: automountServiceAccountToken: false<br>ServiceAccount에서 이 설정을 false로 하면 토큰이 자동으로 마운트되지 않습니다.'
            },
            {
                type: 'multiple',
                correct: ['B'],
                explanation: '정답: B. kubectl auth can-i --list<br>현재 사용자가 가진 모든 권한을 나열해서 보여줍니다.'
            },
            {
                type: 'text',
                correct: ['serviceAccountName'],
                explanation: '정답: serviceAccountName<br>Pod spec에서 serviceAccountName 필드로 사용할 ServiceAccount를 지정합니다.'
            },
            {
                type: 'multiple',
                correct: ['B'],
                explanation: '정답: B. kubectl create clusterrolebinding cluster-reader --clusterrole=reader --serviceaccount=default:sa<br>ClusterRoleBinding 생성을 위한 정확한 명령어 구조입니다.'
            },
            {
                type: 'text',
                correct: ['kubectl auth can-i get pods', 'kubectl auth can-i <verb> <resource>'],
                explanation: '정답: kubectl auth can-i <verb> <resource><br>특정 동작이 허용되는지 확인하는 명령어로 권한 문제를 진단할 수 있습니다.'
            },
            {
                type: 'multiple',
                correct: ['C'],
                explanation: '정답: C. 모든 리소스에 모든 권한을 가진 ClusterRole<br>이는 최소 권한 원칙에 완전히 위배되는 매우 위험한 설정입니다.'
            }
        ];

        let currentQuestion = 0;
        let score = 0;
        let answered = new Array(questions.length).fill(false);

        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const checkBtn = document.getElementById('checkBtn');
        const hintBtn = document.getElementById('hintBtn');
        const results = document.getElementById('results');

        function updateProgress() {
            const progress = ((currentQuestion + 1) / questions.length) * 100;
            progressBar.style.width = `${progress}%`;
            progressText.textContent = `${currentQuestion + 1} / ${questions.length}`;
        }

        function showQuestion(index) {
            document.querySelectorAll('.question-container').forEach(container => {
                container.classList.remove('active');
            });
            
            document.querySelector(`[data-question="${index}"]`).classList.add('active');
            
            prevBtn.disabled = index === 0;
            nextBtn.disabled = !answered[index];
            
            if (answered[index]) {
                checkBtn.textContent = '정답입니다!';
                checkBtn.style.background = '#10b981';
                checkBtn.disabled = true;
                nextBtn.disabled = false;
            } else {
                checkBtn.textContent = '정답 확인';
                checkBtn.style.background = 'linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%)';
                checkBtn.disabled = false;
            }
            
            updateProgress();
        }

        function checkAnswer() {
            const currentQuestionElement = document.querySelector(`[data-question="${currentQuestion}"]`);
            const question = questions[currentQuestion];
            const feedback = currentQuestionElement.querySelector('.feedback');
            let isCorrect = false;
            let selectedAnswer = '';

            if (question.type === 'multiple') {
                const selectedOption = currentQuestionElement.querySelector('.option.selected');
                if (!selectedOption) return;
                
                selectedAnswer = selectedOption.dataset.answer;
                isCorrect = question.correct.includes(selectedAnswer);
                
                // 모든 옵션 비활성화
                currentQuestionElement.querySelectorAll('.option').forEach(opt => {
                    opt.style.pointerEvents = 'none';
                    if (question.correct.includes(opt.dataset.answer)) {
                        opt.classList.add('correct');
                    } else if (opt.classList.contains('selected')) {
                        opt.classList.add('incorrect');
                    }
                });
            } else {
                const input = currentQuestionElement.querySelector('.answer-input');
                selectedAnswer = input.value.trim().toLowerCase();
                
                isCorrect = question.correct.some(answer => 
                    selectedAnswer.includes(answer.toLowerCase()) || 
                    answer.toLowerCase().includes(selectedAnswer)
                );
                
                input.disabled = true;
                input.classList.add(isCorrect ? 'correct' : 'incorrect');
            }

            // 피드백 표시
            feedback.innerHTML = question.explanation;
            feedback.className = `feedback ${isCorrect ? 'correct' : 'incorrect'} show`;

            if (isCorrect) {
                if (!answered[currentQuestion]) {
                    score++;
                }
                answered[currentQuestion] = true;
                checkBtn.textContent = '정답입니다!';
                checkBtn.style.background = '#10b981';
                checkBtn.disabled = true;
                nextBtn.disabled = false;
            } else {
                checkBtn.textContent = '다시 시도하기';
                checkBtn.style.background = '#ef4444';

                // 오답 시 재시도 가능하도록 수정
                if (question.type === 'multiple') {
                    setTimeout(() => {
                        currentQuestionElement.querySelectorAll('.option').forEach(opt => {
                            opt.classList.remove('selected', 'correct', 'incorrect');
                            opt.style.pointerEvents = 'auto';
                        });
                        feedback.classList.remove('show');
                        checkBtn.textContent = '정답 확인';
                        checkBtn.style.background = 'linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%)';
                        answered[currentQuestion] = false;
                    }, 1500);
                } else {
                    setTimeout(() => {
                        currentQuestionElement.querySelector('.answer-input').disabled = false;
                        currentQuestionElement.querySelector('.answer-input').classList.remove('correct', 'incorrect');
                        feedback.classList.remove('show');
                        checkBtn.textContent = '정답 확인';
                        checkBtn.style.background = 'linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%)';
                        answered[currentQuestion] = false;
                    }, 1500);
                }
            }
        }

        function showResults() {
            document.querySelector('.quiz-header').style.display = 'none';
            document.querySelectorAll('.question-container').forEach(container => {
                container.style.display = 'none';
            });
            document.querySelector('.controls').style.display = 'none';
            
            const finalScore = document.getElementById('finalScore');
            const scoreMessage = document.getElementById('scoreMessage');
            const scoreDetail = document.getElementById('scoreDetail');
            const medal = document.getElementById('medal');
            
            finalScore.textContent = `${score}/12`;
            
            if (score >= 10) {
                medal.textContent = '🥇';
                scoreMessage.textContent = 'ServiceAccount & RBAC 마스터!';
                scoreDetail.textContent = '완벽한 권한 관리 전문가입니다!';
            } else if (score >= 8) {
                medal.textContent = '🥈';
                scoreMessage.textContent = 'RBAC 전문가!';
                scoreDetail.textContent = '뛰어난 Kubernetes 보안 지식을 보여주었습니다!';
            } else if (score >= 6) {
                medal.textContent = '🥉';
                scoreMessage.textContent = 'RBAC 실력자!';
                scoreDetail.textContent = '권한 관리 기초를 잘 이해하고 있습니다!';
            } else {
                medal.textContent = '📚';
                scoreMessage.textContent = 'RBAC 학습 중!';
                scoreDetail.textContent = '복습 후 다시 도전해보세요!';
            }
            
            results.classList.add('show');
        }

        // Event Listeners
        prevBtn.addEventListener('click', () => {
            if (currentQuestion > 0) {
                currentQuestion--;
                showQuestion(currentQuestion);
            }
        });

        nextBtn.addEventListener('click', () => {
            if (currentQuestion < questions.length - 1) {
                currentQuestion++;
                showQuestion(currentQuestion);
            } else {
                showResults();
            }
        });

        checkBtn.addEventListener('click', checkAnswer);

        hintBtn.addEventListener('click', () => {
            const currentQuestionElement = document.querySelector(`[data-question="${currentQuestion}"]`);
            const hint = currentQuestionElement.querySelector('.hint');
            hint.classList.toggle('show');
        });

        // 옵션 선택 처리
        document.addEventListener('click', (e) => {
            if (e.target.closest('.option')) {
                const option = e.target.closest('.option');
                const container = option.closest('.question-container');
                
                // 기존 선택 제거
                container.querySelectorAll('.option').forEach(opt => {
                    opt.classList.remove('selected');
                });
                
                // 새 선택 추가
                option.classList.add('selected');
            }
        });

        // Enter 키 처리
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                if (!checkBtn.disabled) {
                    checkAnswer();
                } else if (!nextBtn.disabled) {
                    nextBtn.click();
                }
            }
        });

        // 모든 정답 보기
        document.getElementById('showAllAnswers').addEventListener('click', () => {
            document.getElementById('allAnswers').classList.toggle('show');
        });

        // 초기화
        showQuestion(0);
    </script>
</body>
</html>