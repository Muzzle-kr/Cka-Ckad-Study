<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Day 1 퀴즈: ConfigMap 기초</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'SF Pro Text', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        .progress-bar {
            background: rgba(255, 255, 255, 0.2);
            height: 8px;
            border-radius: 4px;
            margin-top: 20px;
            overflow: hidden;
        }
        
        .progress-fill {
            background: #10b981;
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 4px;
        }
        
        .quiz-content {
            padding: 40px;
        }
        
        .question {
            background: #f8fafc;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            border-left: 5px solid #4f46e5;
            display: none;
        }
        
        .question.active {
            display: block;
        }
        
        .question h3 {
            color: #1f2937;
            font-size: 1.3rem;
            margin-bottom: 20px;
            line-height: 1.6;
        }
        
        .question-meta {
            color: #6b7280;
            font-size: 0.9rem;
            margin-bottom: 15px;
            font-weight: 500;
        }
        
        .answer-input {
            width: 100%;
            padding: 15px;
            font-size: 16px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', monospace;
            background: #f9fafb;
            margin-bottom: 15px;
            transition: border-color 0.3s ease;
        }
        
        .answer-input:focus {
            outline: none;
            border-color: #4f46e5;
            background: white;
        }
        
        .options {
            margin-bottom: 20px;
        }
        
        .option {
            background: #f9fafb;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
        }
        
        .option:hover {
            background: #f3f4f6;
            border-color: #d1d5db;
        }
        
        .option.selected {
            background: #ede9fe;
            border-color: #8b5cf6;
            color: #5b21b6;
        }
        
        .option.correct {
            background: #d1fae5;
            border-color: #10b981;
            color: #047857;
        }
        
        .option.incorrect {
            background: #fef2f2;
            border-color: #ef4444;
            color: #dc2626;
        }
        
        .check-button {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-right: 15px;
        }
        
        .check-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(79, 70, 229, 0.3);
        }
        
        .check-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .hint-button {
            background: #f59e0b;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .hint-button:hover {
            background: #d97706;
            transform: translateY(-2px);
        }
        
        .feedback {
            margin-top: 20px;
            padding: 20px;
            border-radius: 8px;
            display: none;
        }
        
        .feedback.show {
            display: block;
        }
        
        .feedback.correct {
            background: #d1fae5;
            border: 1px solid #10b981;
            color: #047857;
        }
        
        .feedback.incorrect {
            background: #fef2f2;
            border: 1px solid #ef4444;
            color: #dc2626;
        }
        
        .hint {
            margin-top: 15px;
            padding: 15px;
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 8px;
            color: #92400e;
            display: none;
        }
        
        .hint.show {
            display: block;
        }
        
        .navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #e5e7eb;
        }
        
        .nav-button {
            background: #6b7280;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .nav-button:hover:not(:disabled) {
            background: #4b5563;
            transform: translateY(-1px);
        }
        
        .nav-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }
        
        .nav-button.primary {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }
        
        .nav-button.primary:hover:not(:disabled) {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
        }
        
        .score-display {
            text-align: center;
            font-weight: 600;
            color: #4b5563;
        }
        
        .final-results {
            text-align: center;
            padding: 40px;
            display: none;
        }
        
        .final-results.show {
            display: block;
        }
        
        .final-score {
            font-size: 3rem;
            font-weight: bold;
            margin-bottom: 20px;
        }
        
        .medal {
            font-size: 4rem;
            margin-bottom: 20px;
        }
        
        .final-message {
            font-size: 1.2rem;
            color: #6b7280;
            margin-bottom: 30px;
        }
        
        .restart-button {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .restart-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(79, 70, 229, 0.3);
        }
        
        .code-block {
            background: #1f2937;
            color: #f9fafb;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 14px;
            margin: 15px 0;
            overflow-x: auto;
        }
        
        .progress-text {
            text-align: center;
            color: white;
            margin-top: 10px;
            font-weight: 500;
        }
        
        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 12px;
            }
            .quiz-content {
                padding: 20px;
            }
            .question {
                padding: 20px;
            }
            .header {
                padding: 20px;
            }
            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>⚙️ Day 1: ConfigMap 기초 퀴즈</h1>
            <p>총 10문제 | CKA/CKAD 준비</p>
            <div class="progress-bar">
                <div class="progress-fill"></div>
            </div>
            <div class="progress-text">
                <span id="current-question">1</span> / <span id="total-questions">10</span>
            </div>
        </div>

        <div class="quiz-content">
            <!-- 문제 1: 객관식 -->
            <div class="question active" data-question="1" data-type="multiple">
                <div class="question-meta">문제 1/10 - 개념 이해</div>
                <h3>ConfigMap에 대한 설명으로 가장 적절한 것은?</h3>
                <div class="options">
                    <div class="option" data-answer="A">A) 민감한 정보(비밀번호, API 키)를 저장하는 Kubernetes 리소스</div>
                    <div class="option" data-answer="B">B) Pod의 컨테이너 이미지를 관리하는 리소스</div>
                    <div class="option" data-answer="C">C) key-value 형태로 비민감한 설정 데이터를 저장하는 리소스</div>
                    <div class="option" data-answer="D">D) 네트워크 설정을 관리하는 서비스 리소스</div>
                </div>
                <div class="feedback correct">
                    <strong>🎉 정답입니다!</strong><br> 정답: C) key-value 형태로 비민감한 설정 데이터를 저장하는 리소스<br> ConfigMap은 애플리케이션 설정, 환경변수, 설정 파일 등 비민감한 데이터를 저장합니다. 민감한 정보는 Secret을 사용해야 합니다.
                </div>
                <div class="feedback incorrect">
                    <strong>❌ 틀렸습니다.</strong><br> ConfigMap은 비민감한 설정 데이터를 key-value 형태로 저장하는 리소스입니다. 민감한 정보는 Secret을 사용합니다.
                </div>
                <div class="hint">
                    💡 힌트: ConfigMap의 'Config'는 설정(Configuration)을 의미하며, 보안이 필요하지 않은 설정 정보를 저장합니다.
                </div>
            </div>

            <!-- 문제 2: 명령어 -->
            <div class="question" data-question="2" data-type="command">
                <div class="question-meta">문제 2/10 - 명령어 실습</div>
                <h3>리터럴 값으로 ConfigMap을 생성하는 명령어를 작성하세요.</h3>
                <p><strong>조건:</strong></p>
                <ul style="margin: 15px 0; padding-left: 20px;">
                    <li>ConfigMap 이름: app-settings</li>
                    <li>키-값: database_url=postgresql://db:5432/myapp</li>
                    <li>키-값: log_level=debug</li>
                </ul>
                <input type="text" class="answer-input" placeholder="kubectl create configmap ...">
                <div class="feedback correct">
                    <strong>🎉 정답입니다!</strong><br> 정답: kubectl create configmap app-settings --from-literal=database_url=postgresql://db:5432/myapp --from-literal=log_level=debug<br> --from-literal 옵션을 사용하여 각 key-value 쌍을 직접 명령어에 지정할 수 있습니다.
                </div>
                <div class="feedback incorrect">
                    <strong>❌ 틀렸습니다.</strong><br> kubectl create configmap 명령어와 --from-literal 옵션을 사용해야 합니다.
                </div>
                <div class="hint">
                    💡 힌트: kubectl create configmap [이름] --from-literal=key1=value1 --from-literal=key2=value2 형식을 사용하세요.
                </div>
            </div>

            <!-- 문제 3: 객관식 -->
            <div class="question" data-question="3" data-type="multiple">
                <div class="question-meta">문제 3/10 - 사용 방법</div>
                <h3>Pod에서 ConfigMap을 활용하는 방법이 아닌 것은?</h3>
                <div class="options">
                    <div class="option" data-answer="A">A) 환경변수로 주입</div>
                    <div class="option" data-answer="B">B) 볼륨으로 마운트</div>
                    <div class="option" data-answer="C">C) 명령줄 인수로 전달</div>
                    <div class="option" data-answer="D">D) 컨테이너 이미지로 빌드</div>
                </div>
                <div class="feedback correct">
                    <strong>🎉 정답입니다!</strong><br> 정답: D) 컨테이너 이미지로 빌드<br> ConfigMap은 런타임에 Pod에 주입되는 설정입니다. 컨테이너 이미지 빌드 시에는 사용되지 않습니다.
                </div>
                <div class="feedback incorrect">
                    <strong>❌ 틀렸습니다.</strong><br> ConfigMap은 환경변수, 볼륨 마운트, 명령줄 인수로 사용 가능하지만 컨테이너 이미지 빌드와는 관련이 없습니다.
                </div>
                <div class="hint">
                    💡 힌트: ConfigMap은 런타임에 Pod에 설정을 제공하는 방법을 생각해보세요.
                </div>
            </div>

            <!-- 문제 4: 명령어 -->
            <div class="question" data-question="4" data-type="command">
                <div class="question-meta">문제 4/10 - 조회 명령어</div>
                <h3>ConfigMap의 데이터 내용을 YAML 형식으로 확인하는 명령어를 작성하세요.</h3>
                <p><strong>조건:</strong> ConfigMap 이름은 my-config입니다.</p>
                <input type="text" class="answer-input" placeholder="kubectl get ...">
                <div class="feedback correct">
                    <strong>🎉 정답입니다!</strong><br> 정답: kubectl get configmap my-config -o yaml<br> -o yaml 옵션을 사용하여 ConfigMap의 전체 내용을 YAML 형식으로 볼 수 있습니다.
                </div>
                <div class="feedback incorrect">
                    <strong>❌ 틀렸습니다.</strong><br> kubectl get configmap [이름] -o yaml 형식을 사용해야 합니다.
                </div>
                <div class="hint">
                    💡 힌트: kubectl get 명령어에 -o yaml 옵션을 추가하세요.
                </div>
            </div>

            <!-- 문제 5: 코드 작성 -->
            <div class="question" data-question="5" data-type="yaml">
                <div class="question-meta">문제 5/10 - YAML 작성</div>
                <h3>다음 ConfigMap YAML에서 누락된 부분을 채우세요.</h3>
                <div class="code-block">apiVersion: v1 kind: ConfigMap metadata: name: web-config data: app_name: "my-web-app" port: "8080" ___________: | server.port=8080 server.host=0.0.0.0
                </div>
                <p><strong>빈 칸에 들어갈 키 이름은?</strong> (설정 파일 내용을 저장하는 적절한 키 이름)</p>
                <input type="text" class="answer-input" placeholder="키 이름을 입력하세요">
                <div class="feedback correct">
                    <strong>🎉 정답입니다!</strong><br> 올바른 답안입니다. 멀티라인 설정 파일은 파이프(|) 문자를 사용하여 저장할 수 있습니다.
                </div>
                <div class="feedback incorrect">
                    <strong>❌ 틀렸습니다.</strong><br> 설정 파일을 나타내는 적절한 키 이름을 생각해보세요. 예: application.properties, config.properties, server.conf 등
                </div>
                <div class="hint">
                    💡 힌트: 일반적으로 Java 애플리케이션에서 사용하는 설정 파일명을 생각해보세요.
                </div>
            </div>

            <!-- 문제 6: 객관식 -->
            <div class="question" data-question="6" data-type="multiple">
                <div class="question-meta">문제 6/10 - 환경변수 주입</div>
                <h3>Pod에서 ConfigMap의 모든 키를 환경변수로 가져오는 YAML 구문은?</h3>
                <div class="options">
                    <div class="option" data-answer="A">
                        A)
                        <div class="code-block">env: - name: ALL_CONFIG valueFrom: configMapRef: name: my-config</div>
                    </div>
                    <div class="option" data-answer="B">
                        B)
                        <div class="code-block">envFrom: - configMapRef: name: my-config</div>
                    </div>
                    <div class="option" data-answer="C">
                        C)
                        <div class="code-block">volumes: - configMap: name: my-config</div>
                    </div>
                    <div class="option" data-answer="D">
                        D)
                        <div class="code-block">env: - configMapKeyRef: name: my-config</div>
                    </div>
                </div>
                <div class="feedback correct">
                    <strong>🎉 정답입니다!</strong><br> 정답: B) envFrom과 configMapRef를 사용<br> envFrom을 사용하면 ConfigMap의 모든 키-값 쌍을 환경변수로 가져올 수 있습니다.
                </div>
                <div class="feedback incorrect">
                    <strong>❌ 틀렸습니다.</strong><br> ConfigMap의 모든 키를 환경변수로 가져오려면 envFrom과 configMapRef를 사용해야 합니다.
                </div>
                <div class="hint">
                    💡 힌트: 'From'이라는 단어가 들어간 필드명을 생각해보세요.
                </div>
            </div>

            <!-- 문제 7: 명령어 -->
            <div class="question" data-question="7" data-type="command">
                <div class="question-meta">문제 7/10 - 파일 기반 생성</div>
                <h3>nginx.conf 파일로부터 ConfigMap을 생성하는 명령어를 작성하세요.</h3>
                <p><strong>조건:</strong> ConfigMap 이름은 nginx-config입니다.</p>
                <input type="text" class="answer-input" placeholder="kubectl create configmap ...">
                <div class="feedback correct">
                    <strong>🎉 정답입니다!</strong><br> 정답: kubectl create configmap nginx-config --from-file=nginx.conf<br> --from-file 옵션을 사용하여 파일 내용으로 ConfigMap을 생성할 수 있습니다.
                </div>
                <div class="feedback incorrect">
                    <strong>❌ 틀렸습니다.</strong><br> --from-file 옵션을 사용해야 합니다.
                </div>
                <div class="hint">
                    💡 힌트: --from-file 옵션을 사용하여 파일에서 ConfigMap을 생성하세요.
                </div>
            </div>

            <!-- 문제 8: 객관식 -->
            <div class="question" data-question="8" data-type="multiple">
                <div class="question-meta">문제 8/10 - 볼륨 마운트</div>
                <h3>ConfigMap을 볼륨으로 마운트할 때 subPath를 사용하는 이유는?</h3>
                <div class="options">
                    <div class="option" data-answer="A">A) ConfigMap의 전체 내용을 마운트하기 위해</div>
                    <div class="option" data-answer="B">B) 특정 키의 값만 특정 파일 경로에 마운트하기 위해</div>
                    <div class="option" data-answer="C">C) ConfigMap의 권한을 설정하기 위해</div>
                    <div class="option" data-answer="D">D) ConfigMap을 암호화하기 위해</div>
                </div>
                <div class="feedback correct">
                    <strong>🎉 정답입니다!</strong><br> 정답: B) 특정 키의 값만 특정 파일 경로에 마운트하기 위해<br> subPath를 사용하면 ConfigMap의 특정 키만 선택하여 원하는 파일명으로 마운트할 수 있습니다.
                </div>
                <div class="feedback incorrect">
                    <strong>❌ 틀렸습니다.</strong><br> subPath는 ConfigMap의 특정 키만 선택적으로 마운트할 때 사용합니다.
                </div>
                <div class="hint">
                    💡 힌트: 'sub'는 '부분적인'을 의미합니다. Path(경로)의 일부만 사용한다는 뜻입니다.
                </div>
            </div>

            <!-- 문제 9: 명령어 -->
            <div class="question" data-question="9" data-type="command">
                <div class="question-meta">문제 9/10 - 수정 명령어</div>
                <h3>ConfigMap에 새로운 키-값을 추가하는 patch 명령어를 작성하세요.</h3>
                <p><strong>조건:</strong></p>
                <ul style="margin: 15px 0; padding-left: 20px;">
                    <li>ConfigMap 이름: app-config</li>
                    <li>추가할 키-값: timeout=30</li>
                </ul>
                <input type="text" class="answer-input" placeholder="kubectl patch configmap ...">
                <div class="feedback correct">
                    <strong>🎉 정답입니다!</strong><br> 정답: kubectl patch configmap app-config -p '{"data":{"timeout":"30"}}'<br> patch 명령어를 사용하여 기존 ConfigMap에 새로운 키-값을 추가할 수 있습니다.
                </div>
                <div class="feedback incorrect">
                    <strong>❌ 틀렸습니다.</strong><br> kubectl patch configmap [이름] -p '{"data":{"key":"value"}}' 형식을 사용해야 합니다.
                </div>
                <div class="hint">
                    💡 힌트: patch 명령어에서 -p 옵션과 JSON 형식을 사용하세요. data 필드 안에 새로운 키-값을 추가합니다.
                </div>
            </div>

            <!-- 문제 10: 객관식 -->
            <div class="question" data-question="10" data-type="multiple">
                <div class="question-meta">문제 10/10 - 주의사항</div>
                <h3>ConfigMap 사용 시 주의사항으로 올바른 것은?</h3>
                <div class="options">
                    <div class="option" data-answer="A">A) ConfigMap 크기는 무제한이다</div>
                    <div class="option" data-answer="B">B) 환경변수로 주입된 ConfigMap은 자동으로 업데이트된다</div>
                    <div class="option" data-answer="C">C) ConfigMap은 1MB 이하로 제한되며, 환경변수 변경 시 Pod 재시작이 필요하다</div>
                    <div class="option" data-answer="D">D) ConfigMap에 민감한 정보(비밀번호)를 저장해도 안전하다</div>
                </div>
                <div class="feedback correct">
                    <strong>🎉 정답입니다!</strong><br> 정답: C) ConfigMap은 1MB 이하로 제한되며, 환경변수 변경 시 Pod 재시작이 필요하다<br> ConfigMap은 크기 제한이 있고, 환경변수는 Pod 시작 시에만 주입되므로 변경 시 재시작이 필요합니다. 볼륨 마운트는 자동 업데이트됩니다.
                </div>
                <div class="feedback incorrect">
                    <strong>❌ 틀렸습니다.</strong><br> ConfigMap은 1MB 제한이 있고, 환경변수 변경 시 Pod 재시작이 필요하며, 민감한 정보는 Secret을 사용해야 합니다.
                </div>
                <div class="hint">
                    💡 힌트: ConfigMap의 크기 제한과 환경변수 업데이트 방식을 생각해보세요.
                </div>
            </div>

            <!-- 네비게이션 -->
            <div class="navigation">
                <button class="nav-button" id="prevBtn" onclick="changeQuestion(-1)" disabled>이전</button>
                <div class="score-display">
                    점수: <span id="score">0</span>/10
                </div>
                <button class="nav-button primary" id="nextBtn" onclick="changeQuestion(1)" disabled>다음</button>
            </div>

            <!-- 버튼 영역 -->
            <div style="text-align: center; margin-top: 30px;">
                <button class="check-button" onclick="checkAnswer()">정답 확인</button>
                <button class="hint-button" onclick="showHint()">💡 힌트</button>
            </div>
        </div>

        <!-- 최종 결과 -->
        <div class="final-results" id="finalResults">
            <div class="medal" id="medal">🏆</div>
            <div class="final-score" id="finalScore">0/10</div>
            <div class="final-message" id="finalMessage">수고하셨습니다!</div>
            <button class="restart-button" onclick="restartQuiz()">다시 시작</button>
        </div>
    </div>

    <script>
        let currentQuestion = 1;
        let totalQuestions = 10;
        let score = 0;
        let answered = Array(totalQuestions + 1).fill(false);

        // 정답 데이터
        const answers = {
            1: 'C',
            2: ['kubectl create configmap app-settings --from-literal=database_url=postgresql://db:5432/myapp --from-literal=log_level=debug'],
            3: 'D',
            4: ['kubectl get configmap my-config -o yaml', 'kubectl get cm my-config -o yaml'],
            5: ['application.properties', 'app.properties', 'config.properties', 'server.properties'],
            6: 'B',
            7: ['kubectl create configmap nginx-config --from-file=nginx.conf'],
            8: 'B',
            9: ['kubectl patch configmap app-config -p \'{"data":{"timeout":"30"}}\'', 'kubectl patch configmap app-config -p "{\"data\":{\"timeout\":\"30\"}}"'],
            10: 'C'
        };

        function updateProgress() {
            const progress = (currentQuestion / totalQuestions) * 100;
            document.querySelector('.progress-fill').style.width = progress + '%';
            document.getElementById('current-question').textContent = currentQuestion;
            document.getElementById('total-questions').textContent = totalQuestions;
        }

        function showQuestion(questionNum) {
            // 모든 문제 숨기기
            document.querySelectorAll('.question').forEach(q => {
                q.classList.remove('active');
            });

            // 현재 문제 보이기
            document.querySelector(`[data-question="${questionNum}"]`).classList.add('active');

            // 정답 확인 버튼 초기화
            const checkButton = document.querySelector('.check-button');
            if (answered[questionNum]) {
                checkButton.textContent = '정답입니다!';
                checkButton.style.background = '#10b981';
                checkButton.disabled = true;
            } else {
                checkButton.textContent = '정답 확인';
                checkButton.style.background = 'linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%)';
                checkButton.disabled = false;
            }

            // 네비게이션 버튼 상태 업데이트
            document.getElementById('prevBtn').disabled = questionNum === 1;

            if (questionNum === totalQuestions) {
                const nextBtn = document.getElementById('nextBtn');
                if (answered[questionNum]) {
                    nextBtn.textContent = '결과 보기';
                    nextBtn.disabled = false;
                } else {
                    nextBtn.textContent = '결과 보기';
                    nextBtn.disabled = true;
                }
            } else {
                document.getElementById('nextBtn').textContent = '다음';
                document.getElementById('nextBtn').disabled = !answered[questionNum];
            }

            updateProgress();
        }

        function changeQuestion(direction) {
            if (direction > 0 && currentQuestion === totalQuestions && answered[currentQuestion]) {
                showResults();
                return;
            }

            const newQuestion = currentQuestion + direction;
            if (newQuestion >= 1 && newQuestion <= totalQuestions) {
                currentQuestion = newQuestion;
                showQuestion(currentQuestion);
            }
        }

        function checkAnswer() {
            const currentQuestionElement = document.querySelector(`[data-question="${currentQuestion}"]`);
            const questionType = currentQuestionElement.getAttribute('data-type');

            let userAnswer;
            let isCorrect = false;

            if (questionType === 'multiple') {
                const selectedOption = currentQuestionElement.querySelector('.option.selected');
                if (!selectedOption) {
                    alert('답을 선택해주세요!');
                    return;
                }
                userAnswer = selectedOption.getAttribute('data-answer');
                isCorrect = userAnswer === answers[currentQuestion];

                // 모든 옵션 비활성화
                currentQuestionElement.querySelectorAll('.option').forEach(opt => {
                    opt.style.pointerEvents = 'none';
                    if (opt.getAttribute('data-answer') === answers[currentQuestion]) {
                        opt.classList.add('correct');
                    } else if (opt.classList.contains('selected')) {
                        opt.classList.add('incorrect');
                    }
                });
            } else {
                const input = currentQuestionElement.querySelector('.answer-input');
                userAnswer = input.value.trim();

                if (!userAnswer) {
                    alert('답을 입력해주세요!');
                    return;
                }

                // 명령어 문제의 경우 여러 정답 허용
                if (Array.isArray(answers[currentQuestion])) {
                    isCorrect = answers[currentQuestion].some(answer =>
                        userAnswer.toLowerCase().includes(answer.toLowerCase()) ||
                        answer.toLowerCase().includes(userAnswer.toLowerCase())
                    );
                } else {
                    isCorrect = userAnswer.toLowerCase() === answers[currentQuestion].toLowerCase();
                }

                input.disabled = true;
            }

            // 피드백 표시
            const feedbackClass = isCorrect ? 'correct' : 'incorrect';
            const feedback = currentQuestionElement.querySelector(`.feedback.${feedbackClass}`);
            feedback.classList.add('show');

            // 점수 업데이트
            if (isCorrect && !answered[currentQuestion]) {
                score++;
                document.getElementById('score').textContent = score;
            }

            answered[currentQuestion] = true;

            // 정답 확인 버튼 업데이트
            const checkButton = document.querySelector('.check-button');
            if (isCorrect) {
                checkButton.textContent = '정답입니다!';
                checkButton.style.background = '#10b981';
            } else {
                checkButton.textContent = '다시 시도하기';
                checkButton.style.background = '#ef4444';
                // 1초 후 다시 시도 가능하게 하기
                setTimeout(() => {
                    if (questionType === 'multiple') {
                        // 객관식은 한 번만 시도 가능
                        checkButton.disabled = true;
                    } else {
                        // 주관식은 다시 시도 가능
                        currentQuestionElement.querySelector('.answer-input').disabled = false;
                        currentQuestionElement.querySelector('.answer-input').value = '';
                        feedback.classList.remove('show');
                        checkButton.textContent = '정답 확인';
                        checkButton.style.background = 'linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%)';
                        answered[currentQuestion] = false;
                    }
                }, 1000);
            }

            // 다음 버튼 활성화
            if (isCorrect) {
                document.getElementById('nextBtn').disabled = false;
                checkButton.disabled = true;
            }
        }

        function showHint() {
            const currentQuestionElement = document.querySelector(`[data-question="${currentQuestion}"]`);
            const hint = currentQuestionElement.querySelector('.hint');
            hint.classList.add('show');
        }

        function showResults() {
            document.querySelector('.quiz-content').style.display = 'none';
            const finalResults = document.getElementById('finalResults');
            finalResults.classList.add('show');

            document.getElementById('finalScore').textContent = `${score}/${totalQuestions}`;

            // 메달과 메시지 설정
            const medal = document.getElementById('medal');
            const message = document.getElementById('finalMessage');

            if (score >= 8) {
                medal.textContent = '🥇';
                message.textContent = '훌륭합니다! ConfigMap을 완벽히 이해하셨네요!';
            } else if (score >= 6) {
                medal.textContent = '🥈';
                message.textContent = '잘했습니다! 조금 더 학습하면 완벽해질 거예요!';
            } else if (score >= 4) {
                medal.textContent = '🥉';
                message.textContent = '기본기는 갖추셨네요! 더 연습해보세요!';
            } else {
                medal.textContent = '📚';
                message.textContent = '다시 학습하고 도전해보세요! 포기하지 마세요!';
            }
        }

        function restartQuiz() {
            currentQuestion = 1;
            score = 0;
            answered = Array(totalQuestions + 1).fill(false);

            // 점수 초기화
            document.getElementById('score').textContent = '0';

            // 모든 문제 초기화
            document.querySelectorAll('.question').forEach(question => {
                // 선택된 옵션 초기화
                question.querySelectorAll('.option').forEach(option => {
                    option.classList.remove('selected', 'correct', 'incorrect');
                    option.style.pointerEvents = 'auto';
                });

                // 입력 필드 초기화
                const input = question.querySelector('.answer-input');
                if (input) {
                    input.value = '';
                    input.disabled = false;
                }

                // 피드백 숨기기
                question.querySelectorAll('.feedback').forEach(feedback => {
                    feedback.classList.remove('show');
                });

                // 힌트 숨기기
                const hint = question.querySelector('.hint');
                if (hint) {
                    hint.classList.remove('show');
                }
            });

            // 버튼 초기화
            const checkButton = document.querySelector('.check-button');
            checkButton.textContent = '정답 확인';
            checkButton.style.background = 'linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%)';
            checkButton.disabled = false;

            // 결과 화면 숨기기
            document.getElementById('finalResults').classList.remove('show');
            document.querySelector('.quiz-content').style.display = 'block';

            // 첫 번째 문제 표시
            showQuestion(1);
        }

        // 옵션 클릭 이벤트
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('.option').forEach(option => {
                option.addEventListener('click', function() {
                    // 같은 문제의 다른 옵션들 선택 해제
                    const questionElement = this.closest('.question');
                    questionElement.querySelectorAll('.option').forEach(opt => {
                        opt.classList.remove('selected');
                    });

                    // 현재 옵션 선택
                    this.classList.add('selected');
                });
            });

            // Enter 키로 정답 확인
            document.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    const checkButton = document.querySelector('.check-button');
                    if (!checkButton.disabled) {
                        checkAnswer();
                    }
                }
            });
        });

        // 초기 화면 설정
        showQuestion(1);
    </script>
</body>

</html>